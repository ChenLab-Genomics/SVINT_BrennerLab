#! /usr/bin/perl

print "# usage: perl my-directory/src/followup_disease_specific_prioritization.pl input_VCF FI_cutoff[e.g.: 0.001] phenotypes[e.g. HPO000001,HPO000002,HPO000003]\n"; 
# this script identifies SVs that are annotated with genes that share at least one of the HPO terms
# this script also use a simple heuristic equation to roughly prioritize SVs that have smaller FIs and that are annotated with genes overlap more HPOs


$sv_anno_file = $ARGV[0];  # the VCF file generated by SVINT
$fi_cut = $ARGV[1];
@hpo = split /,\s?/, $ARGV[2];
my %hpo; map{$hpo{$_}=1}@hpo;
die "No HPO terms provided or wrong format!\n" if scalar(keys %hpo)==0;
$out_file = $sv_anno_file."_FIcut$fi_cut\_prioritized_SVs.txt";

$hpo_file = "data/gene_anno/HPO_ALL_SOURCES_ALL_FREQUENCIES_genes_to_phenotype_20190518.txt";

open H, $hpo_file;
while(<H>){
        chomp;
        ($id, $gn, $term, $hpo) = split /\t/;
        $gn2hpo{$gn}{$hpo} = 1;
        $hpo2gn{$hpo}{$gn} = 1;
}
close H || die "HPO annotation file not found or not accessible\n";

open I, $sv_anno_file;
open O, ">$out_file";
print O "# cut-off: FI <= 0.001 for both the 1000Genome FI and the gnomAD FI\n";
print O "# Only SVs that are annotated by SVINT with genes (by TAD or regulatory target prediction) that share HPOs with input HPOs are included in this file.\n";
print O "# The heuristic scores are provided as an arbitary score, and have not been evaluated extensively on how well they represent the potential of pathogenicity. Please use the heuristic scores with great caution.\n";
print O "#CHR\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tOverlap_With_Gene_Exons\tOverlap_with_genic_noncoding\tTAD_Boundary_Cellines\tMatched_genes_by_TAD";
print O "\tRegulatory_Target_Genes(100%IMPACT & >=2methods)\tMatched_Regulatory_Target_Genes(100%IMPACT & >=2methods)\tRegulatory_Target_Genes(100%IMPACT & >=1method)\tMatched_Regulatory_Target_Genes(100%IMPACT & >=1method)";
print O "\tRegulatory_Target_Genes(>=50%IMPACT & >=2methods)\tMatched_Regulatory_Target_Genes(>=50%IMPACT & >=2methods)\tRegulatory_Target_Genes(>=50%IMPACT & >=1method)\tMatched_Regulatory_Target_Genes(>=50%IMPACT & >=1method)";
print O "\tRegulatory_Target_Genes(>0%IMPACT & >=2methods)\tMatched_Regulatory_Target_Genes(>0%IMPACT & >=2methods)\tRegulatory_Target_Genes(>0%IMPACT & >=1method)\tMatched_Regulatory_Target_Genes(>0%IMPACT & >=1method)";
print O "\tHeuristic_score\n";
while(<I>){
	next if $_ =~ /^#/; chomp;
	undef $chr; undef $pos; undef $id; undef $ref; undef $alt; undef $qual; undef $filter; undef $info; undef $format; undef $gt; undef $over; undef $anno;
	($chr, $pos, $id, $ref, $alt, $qual, $filter, $info, $format, $gt, $over, $anno) = split /\t/;
	$exon = "."; $noncoding = ".";
	for $o(split ";", $over){
		if($o =~ /exonic regions.*: (.*)/){
			$exon = $1; 
		}
		if($o =~ /noncoding regions.*: (.*)/){
			$noncoding = $1;
		}
	}
	undef $tad; undef $tar6; undef $tar5; undef $tar4; undef $tar3; undef $tar2; undef $tar1; undef %tar6; undef %tar5; undef %tar4; undef %tar3; undef %tar2; undef %tar1; 
	undef $tad_m; undef $tar6_m; undef $tar5_m; undef $tar4_m; undef $tar3_m; undef $tar2_m; undef $tar1_m;
	if($anno =~ /\|/){
		($tad, $anno100, $anno50, $anno0) = split /\|/, $anno;
		$tad = "." if $tad eq "-";
		undef %tad_g;
		if($tad ne "."){
			for $tt(split ";", $tad){
				if($tt =~ /\((.*)\)/){
					next if $1 eq "-";
					for $gn(split ",", $1){
						$tad_g{$gn} = 1;
					}
				}
			}
		}
undef %see_tad_m_h; my $see_tad_m_g = 0;
		for $g(sort keys %tad_g){
			undef %tmp_h; undef $tmp_h;
			for $h(sort keys %{$gn2hpo{$g}}){
				next if (!exists $hpo{$h});
				$tmp_h{$h} = 1;
				$see_tad_m_h{$h} = 1;
			}
			if(scalar(keys %tmp_h) >= 1){
				$tmp_h = join ";", sort keys %tmp_h;
				$see_tad_m_g ++;
				if(!$tad_m){
					$tad_m = $g."($tmp_h)";
				}else{  
					$tad_m = "$tad_m,$g($tmp_h)";
				}
			}
		}
		if($anno100 ne "-"){
			for $t(split ";", $anno100){
				undef $g; undef $fs; undef $ms;
				undef $f1; undef $f2; undef $fi1; undef $fi2;
				$t =~ /--(.*)\((.*)!(.*FI.*)!.*\)/;
				$g = $1; $ms = $2; $fs = $3;
				($f1, $f2) = split ",", $fs;
				if($f1 =~ /1000G_FI=(.*)\[/){
					$fi1 = $1;
				}
				if($f2 =~ /gnomAD_FI=(.*)\[/){
					$fi2 = $1;
				}
				next if $fi1 > $fi_cut;
				next if $fi2 > $fi_cut;
				$tar2{$g}=1;
				$tar4{$g}=1;
				$tar6{$g}=1;
				for $m(split ",", $ms){
					$tar1{$g}{$m}=1;
					$tar3{$g}{$m}=1;
					$tar5{$g}{$m}=1;
				}
			}
		}
		if($anno50 ne "-"){
			for $t(split ";", $anno50){
				undef $g; undef $fs; undef $ms;
				undef $f1; undef $f2; undef $fi1; undef $fi2;
				$t =~ /--(.*)\((.*)!(.*FI.*)!.*\)/;
				$g = $1; $ms = $2; $fs = $3;
				($f1, $f2) = split ",", $fs;
				if($f1 =~ /1000G_FI=(.*)\[/){
					$fi1 = $1;
				}
				if($f2 =~ /gnomAD_FI=(.*)\[/){
					$fi2 = $1;
				}
				next if $fi1 > $fi_cut;
				next if $fi2 > $fi_cut;
				$tar4{$g}=1;
				$tar6{$g}=1;
				for $m(split ",", $ms){
					$tar3{$g}{$m}=1;
					$tar5{$g}{$m}=1;
				}
			}
		}
		if($anno0 ne "-"){
			for $t(split ";", $anno0){
				undef $g; undef $fs; undef $ms;
				undef $f1; undef $f2; undef $fi1; undef $fi2;
				$t =~ /--(.*)\((.*)!(.*FI.*)!.*\)/;
				$g = $1; $ms = $2; $fs = $3;
				($f1, $f2) = split ",", $fs;
				if($f1 =~ /1000G_FI=(.*)\[/){
					$fi1 = $1;
				}
				if($f2 =~ /gnomAD_FI=(.*)\[/){
					$fi2 = $1;
				}
				next if $fi1 > $fi_cut;
				next if $fi2 > $fi_cut;
				$tar6{$g}=1;
				for $m(split ",", $ms){
					$tar5{$g}{$m}=1;
				}
			}
		}
		for $g1(sort keys %tar1){
			next if scalar(keys %{$tar1{$g1}}) < 2;
			if(!$tar1){
				$tar1 = $g1;
			}else{
				$tar1 = "$tar1,$g1";
			}
			undef %tmp_h; undef $tmp_h;
			for $h(sort keys %{$gn2hpo{$g1}}){
				next if (!exists $hpo{$h});
				$tmp_h{$h} = 1;
			}
			if(scalar(keys %tmp_h) >= 1){
				$tmp_h = join ";", sort keys %tmp_h;
				if(!$tar1_m){
					$tar1_m = $g1."($tmp_h)";
				}else{
					$tar1_m = "$tar1_m,$g1($tmp_h)";
				}
			}
		}
		for $g3(sort keys %tar3){
			next if scalar(keys %{$tar3{$g3}}) < 2;
			if(!$tar3){
				$tar3 = $g3;
			}else{
				$tar3 = "$tar3,$g3";
			}
			undef %tmp_h; undef $tmp_h;
			for $h(sort keys %{$gn2hpo{$g3}}){
				next if (!exists $hpo{$h});
				$tmp_h{$h} = 1;
			}
			if(scalar(keys %tmp_h) >= 1){
				$tmp_h = join ";", sort keys %tmp_h;
				if(!$tar3_m){
					$tar3_m = $g3."($tmp_h)";
				}else{
					$tar3_m = "$tar3_m,$g3($tmp_h)";
				}
			}
		}
		for $g5(sort keys %tar5){
			next if scalar(keys %{$tar5{$g5}}) < 2;
			if(!$tar5){
				$tar5 = $g5;
			}else{
				$tar5 = "$tar5,$g5";
			}
			undef %tmp_h; undef $tmp_h;
			for $h(sort keys %{$gn2hpo{$g5}}){
				next if (!exists $hpo{$h});
				$tmp_h{$h} = 1;
			}
			if(scalar(keys %tmp_h) >= 1){
				$tmp_h = join ";", sort keys %tmp_h;
				if(!$tar5_m){
					$tar5_m = $g5."($tmp_h)";
				}else{  
					$tar5_m = "$tar5_m,$g5($tmp_h)";
				}
			}
		}
		$tar2 = join ",", sort keys %tar2;
		$tar4 = join ",", sort keys %tar4;
		$tar6 = join ",", sort keys %tar6;
		for $g2(sort keys %tar2){
			undef %tmp_h; undef $tmp_h;
			for $h(sort keys %{$gn2hpo{$g2}}){
				next if (!exists $hpo{$h});
				$tmp_h{$h} = 1;
			}
			if(scalar(keys %tmp_h) >= 1){
				$tmp_h = join ";", sort keys %tmp_h;
				if(!$tar2_m){
					$tar2_m = $g2."($tmp_h)";
				}else{  
					$tar2_m = "$tar2_m,$g2($tmp_h)";
				}
			}
		}
		for $g4(sort keys %tar4){
			undef %tmp_h; undef $tmp_h;
			for $h(sort keys %{$gn2hpo{$g4}}){
				next if (!exists $hpo{$h});
				$tmp_h{$h} = 1;
			}
			if(scalar(keys %tmp_h) >= 1){
				$tmp_h = join ";", sort keys %tmp_h;
				if(!$tar4_m){
					$tar4_m = $g4."($tmp_h)";
				}else{
					$tar4_m = "$tar4_m,$g4($tmp_h)";
				}
			}
		}
		undef %see_m_h; my $see_m_g = 0;
		for $g6(sort keys %tar6){
			undef %tmp_h; undef $tmp_h;
			for $h(sort keys %{$gn2hpo{$g6}}){
				next if (!exists $hpo{$h});
				$tmp_h{$h} = 1;
				$see_m_h{$h} = 1;
			}
			if(scalar(keys %tmp_h) >= 1){
				$tmp_h = join ";", sort keys %tmp_h;
				$see_m_g ++;
				if(!$tar6_m){
					$tar6_m = $g6."($tmp_h)";
				}else{
					$tar6_m = "$tar6_m,$g6($tmp_h)";
				}
			}
		}
	}else{
		$tad = ".", $tar1 = "."; $tar2 = "."; $tar3 = "."; $tar4 = "."; $tar5 = "."; $tar6 = ".";
		$tad_m = "."; $tar1_m = "."; $tar2_m = "."; $tar3_m = "."; $tar4_m = "."; $tar5_m = "."; $tar6_m = ".";
	}
	$tad_m = "." if !$tad_m;
	$tar1 = "." if !$tar1; # 100% IMPACT, >=2 METHODS
		$tar2 = "." if !$tar2; # 100% IMPACT, >=1 METHOD
		$tar3 = "." if !$tar3; # 50% IMPACT, >=2 METHODS
		$tar4 = "." if !$tar4; # 50% IMPACT, >=1 METHOD
		$tar5 = "." if !$tar5; # 0% IMPACT, >=2 METHODS
		$tar6 = "." if !$tar6; # 0% IMPACT, >=1 METHOD
		$tar1_m = "." if !$tar1_m; # 100% IMPACT, >=2 METHODS
		$tar2_m = "." if !$tar2_m; # 100% IMPACT, >=1 METHOD
		$tar3_m = "." if !$tar3_m; # 50% IMPACT, >=2 METHODS
		$tar4_m = "." if !$tar4_m; # 50% IMPACT, >=1 METHOD
		$tar5_m = "." if !$tar5_m; # 0% IMPACT, >=2 METHODS
		$tar6_m = "." if !$tar6_m; # 0% IMPACT, >=1 METHOD
# do not output if no gene was matched
		next if ($tar6_m eq "." && $tad_m eq ".");
# scoring: confidence of targets; matched numbers of HPOs; matched numbers of genes; modifier (SV types)
	my $score = 0; my $s_conf = 0; my $s_noh = 0; my $s_tad_noh = 0; my $s_nog = 0; my $s_tad_nog = 0; undef $s_m;
	if($alt =~ /DEL|DUP|T|CNV/){
		$s_m = 0;
	}elsif($alt =~ /INV|INS/){
		$s_m = 0.25;
	}else{
		$s_m = 0.5;
	}
# confidence of predicted targets
	if($tar1_m ne "."){
		$s_conf = 1;
	}elsif($tar3_m ne "."){
		$s_conf = 1;
	}elsif($tar2_m ne "."){
		$s_conf = 0.75;
	}elsif($tar4_m ne "."){
		$s_conf = 0.75;
	}else{
		$s_conf = 0.5;
	}
# matched numbers of HPOs
	$s_tad_noh = scalar(keys %see_tad_m_h)/scalar(keys %hpo); # the percentage of HPO terms matched by TAD
	$s_noh = scalar(keys %see_m_h)/scalar(keys %hpo); # the percentage of HPO terms matched by target genes (0% IMPACT, >=1 METHOD)
# matched numbers of genes
	if($see_tad_m_g >2){
		$s_tad_nog = 1;
	}elsif($see_tad_m_g > 1){
		$s_tad_nog = 0.75;
	}else{
		$s_tad_nog = 0.5;
	}
	if($see_m_g >2){
		$s_nog = 1;
	}elsif($see_m_g > 1){
		$s_nog = 0.75;
	}else{
		$s_nog = 0.5;
	}
# compute the heuristic score
	if(scalar(keys %see_m_h) >= 1 || scalar(keys %see_tad_m_h) >= 1){
		$score = log((exp($s_tad_noh - $s_m) + exp($s_tad_nog - $s_m) + exp(($s_noh - $s_m) * $s_conf) + exp(($s_nog - $s_m) * $s_conf))/4);
	}else{
		$score = 0; # should not exist score = 0 since SV without gene matched would not be output
	}
	print O "$chr\t$pos\t$id\t$ref\t$alt\t$qual\t$filter\t$info\t$exon\t$noncoding\t$tad\t$tad_m\t$tar1\t$tar1_m\t$tar2\t$tar2_m\t$tar3\t$tar3_m\t$tar4\t$tar4_m\t$tar5\t$tar5_m\t$tar6\t$tar6_m\t$score\n";
}
close I || die;
close O || die;
